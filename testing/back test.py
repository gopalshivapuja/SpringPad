import warnings

# Suppress unnecessary warnings from libraries
warnings.filterwarnings('ignore')

# Attempt to specifically suppress the NotOpenSSLWarning before yfinance is imported
try:
    from urllib3.exceptions import NotOpenSSLWarning
    warnings.filterwarnings('ignore', category=NotOpenSSLWarning)
except ImportError:
    pass # Ignore if urllib3 or the specific warning class isn't found

import yfinance as yf
import pandas as pd
import numpy as np

def run_sma_backtest(ticker, start_date, end_date, short_window, long_window):
    """
    Performs a simple Simple Moving Average (SMA) crossover backtest.

    Args:
        ticker (str): The stock ticker symbol (e.g., 'INFY.NS').
        start_date (str): The start date for historical data (YYYY-MM-DD).
        end_date (str): The end date for historical data (YYYY-MM-DD).
        short_window (int): The window size for the short-term SMA.
        long_window (int): The window size for the long-term SMA.
    """
    print(f"--- Running SMA Crossover Backtest for {ticker} ---")
    print(f"Period: {start_date} to {end_date}")
    print(f"SMA Windows: {short_window} (short), {long_window} (long)")

    # 1. Download historical stock data
    try:
        data = yf.download(ticker, start=start_date, end=end_date, progress=False)
        if data.empty:
            print(f"Error: No data downloaded for {ticker}. Check ticker symbol and date range.")
            return
    except Exception as e:
        print(f"Error downloading data for {ticker}: {e}")
        return

    # 2. Calculate Short-term and Long-term Simple Moving Averages (SMAs)
    df = pd.DataFrame(data)
    
    # Ensure columns are single-level index (handle potential MultiIndex from yfinance)
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
        
    df['Short_SMA'] = df['Close'].rolling(window=short_window).mean()
    df['Long_SMA'] = df['Close'].rolling(window=long_window).mean()

    # 3. Generate trading signals
    #    - Signal = 1: Short SMA > Long SMA (Potential Buy Signal)
    #    - Signal = 0: Short SMA <= Long SMA (Potential Sell/Hold Signal)
    df['Signal'] = np.where(df['Short_SMA'] > df['Long_SMA'], 1, 0)

    #    - Position = 1: Crossover from 0 to 1 (Buy)
    #    - Position = -1: Crossover from 1 to 0 (Sell)
    #    - Position = 0: No change
    df['Position'] = df['Signal'].diff()

    # 4. Remove rows with NaN values (generated by rolling means and diff)
    df = df.dropna()

    # 5. Simulate trades based on signals
    trades = []
    active_buy_price = 0  # Track the price of the current active buy position

    # Iterate through each day in the cleaned data
    for i in range(len(df)):
        # Check for a Buy signal (Position == 1)
        if df['Position'].iloc[i] == 1:
            # If we are not already holding a position (active_buy_price == 0)
            # and there is a next day's data available to get the open price
            if active_buy_price == 0 and i + 1 < len(df):
                # Record the next day's open price as the buy price
                active_buy_price = df['Open'].iloc[i + 1]
                buy_date = df.index[i + 1]
                print(f"  BUY Signal:  Price={active_buy_price:.2f}, Date={buy_date.date()}")

        # Check for a Sell signal (Position == -1)
        elif df['Position'].iloc[i] == -1:
            # If we are currently holding a position (active_buy_price > 0)
            # and there is a next day's data available to get the open price
            if active_buy_price > 0 and i + 1 < len(df):
                # Record the next day's open price as the sell price
                sell_price = df['Open'].iloc[i + 1]
                sell_date = df.index[i + 1]
                
                # Calculate profit for this trade
                profit = sell_price - active_buy_price
                profit_percent = (profit / active_buy_price) * 100
                
                # Record the completed trade details
                trades.append({
                    'Buy Price': active_buy_price,
                    'Sell Price': sell_price,
                    'Profit': profit,
                    'Profit Pct': profit_percent
                })
                
                print(f"  SELL Signal: Price={sell_price:.2f}, Date={sell_date.date()} | Profit={profit:.2f} ({profit_percent:.2f}%)")
                print("  " + "-"*48) # Separator line
                
                # Reset active_buy_price as the position is now closed
                active_buy_price = 0 

    # 6. Summarize the backtest results
    print("\n--- Backtest Summary ---")
    if trades:
        trades_df = pd.DataFrame(trades)
        total_profit = trades_df['Profit'].sum()
        win_rate = (trades_df['Profit'] > 0).mean() * 100
        num_trades = len(trades)
        avg_profit = total_profit / num_trades if num_trades > 0 else 0
        
        print(f"Total Trades Executed: {num_trades}")
        print(f"Overall Profit/Loss: {total_profit:.2f}")
        print(f"Average Profit/Loss per Trade: {avg_profit:.2f}")
        print(f"Win Rate: {win_rate:.2f}%")
    else:
        print("No completed trades were executed during this period.")
    print("-" * 50)

# --- Configuration --- 
# Change the ticker symbol here to test different stocks
if __name__ == "__main__":
    # You can easily change the ticker symbol on the next line:
    stock_ticker = "^NSEI"  
    
    # You can also adjust dates and SMA windows if needed:
    start_date = '2000-01-01'
    end_date = '2025-03-31'
    short_sma = 50
    long_sma = 100
    
    # Run the backtest with the specified ticker
    run_sma_backtest(stock_ticker, start_date, end_date, short_sma, long_sma)
    
    # Example: Run with different parameters
    # run_sma_backtest("RELIANCE.NS", start_date='2022-01-01', short_window=20, long_window=50)
